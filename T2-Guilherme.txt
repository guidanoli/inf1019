
$center$$underline$Trabalho 2 - Algoritmos de substituição de páginas

$right$Guilherme Dantas
$right$1713155

$line$

Arquivos no diretório:

colours.h           interface de cores
getresults.sh       script shell para gerar resultados
hourglass.c         fonte do módulo de ampulheta
hourglass.h         interface do módulo de ampulheta
Makefile            arquivo Make
page.c              fonte do módulo de página
page.h              inferface do módulo de página
results.txt         texto gerado pelo script shell
sim-virtual.c       módulo principal (simulador)
t.hourglass.c       teste do módulo de ampulheta
t.page.c            teste do módulo de página
t.utils.c           teste do módulo de utilidades
T2-Guilherme.txt    este documento
test.c              fonte do módulo de testes
test.h              interface do módulo de testes
utils.c             fonte do módulo de utilidades
utils.h             interface do módulo de utilidades

$line$

$center$$underline$Estrutura geral

O simulador possui uma parte genérica e outra específica.
A parte específica depende do algoritmo escolhido pelo primeiro
parâmetro passado ao programa. Ela tratará das estruturas de
dados condizentes com o algoritmo de substituição de páginas
selecionado, nas seguintes ocasiões:

- Inicialização - inicializar estruturas de dados
- Page Fault    - encontrar página a ser substituída
- Atualização   - atualizar informações de página acessada
- Destruição    - destruir estruturas de dados

Um algoritmo não precisa necessariamente implementar alguma
funcionalidade para cada uma dessas ocasiões. Em questão de
implementação, estas "ocasiões" se traduzem na chamada de
uma função num vetor de ponteiros para funções. O algoritmo
selecionado se traduz num índice que acessa a função daquele
algoritmo.

$line$

$center$$underline$NRU

- Inicialização: Alocado vetor para cada página possível,
que armazenará os candidatos a "vítima" de substuição quando
ocorre um Page Fault.

- Page Fault: Identifica os melhores candidatos a vítima (menor
classe de prioridade possível), os põe no vetor de candidatos a
vítimas. A vítima é escolhida aleatoriamente dentre os candidatos.

- Atualização: Zera a flag R a cada ciclo. Seta 1 a flag R da
página acessada.

- Destruição: Desaloca vetor de candidatos a vítima.

$line$

$center$$underline$LRU

- Inicialização: Atribui a cada página da tabela de páginas no
campo "informação", o valor 0. A semântica deste campo genérico
neste algoritmo é de "idade". Este campo é encarado como um
unsigned long, portanto, não precisa ser reiniciado de tempos em
tempos, pois o maior valor assumido é muito maior que a quantidade
de linhas dos arquivos de simulação.

- Page Fault: É escolhida a página mais velha da memória principal.

- Atualização: Atribui ao campo de idade da página acessada o valor
do contador que é incrementado a cada nova linha lida (tempo).

- Destruição: Nada.

$line$

$center$$underline$NOVO (Ótimo)

- Inicialização: É alocado um vetor do tamanho do arquivo (#linhas),
e armazenado na i-ésima posição o índice da página acessada no tempo
i. Erros de formatação do arquivo podem ser levantados nessa etapa.

- Page Fault: Escolhe a página que está em memória que mais tardiamente
será acessada. Caso houver páginas em memória que nunca mais serão
acessadas, é escolhida a primeira nesta categoria.

- Atualização: Nada.

- Destruição: Desaloca vetor de histórico de acessos.

$line$

$center$$underline$Análise de Desempenho

É possível ver nitidamente nas tabelas geradas pelo script, que há um
algoritmo melhor que outro, em todos os casos de testes para os mesmos
parâmetros (tamanho de página x arquivo).

$center$NOVO é melhor que LRU, que é melhor que NRU

Isto é, para as mesmas configurações de tamanho de página e programas
acessando a memória, o algoritmo NOVO é o melhor, depois LRU, e, por
fim, NRU - o que é um bom sinal, pois realmente esperava-se que O NOVO
tivesse a melhor perfomance dos três em quaisquer circunstâncias.

Já quanto ao número de falhas de página, não foi possível fazer uma
relação global, pois varia demais, dependendo do arquivo. Ora aumenta
o número de page faults ao aumentar o tamanho da página, ora diminui.
Há vezes inclusive que este número oscila (LRU para compilador).
Contudo, pode-se tentar explicar o por quê desta variação de PFs
para dado tipo de programa.

$line$

$center$$underline$Compilador

* NRU:  aumentou
* LRU:  oscilou
* NOVO: diminuiu

Nenhum algoritmo se comportou da mesma forma.

$line$

$center$$underline$Compressor

* NRU:  diminuiu
* LRU:  diminuiu
* NOVO: diminuiu

Todos diminuiram. Interessante, porque este foi o único teste
em que o número de páginas escritas foi zero para todos. Pode-se
entender o compressor como um programa pequeno, ou, em outras
palavras, um programa que acessa uma região de memória bem enxuta.
Por isso, aumentar o número de páginas aumenta as chances de
page hit, e, consequentemente, diminui as de page fault.

$line$

$center$$underline$Matriz

* NRU:  aumentou
* LRU:  diminuiu
* NOVO: diminuiu



$line$

$center$$underline$Simulador

* NRU:  aumentou
* LRU:  diminuiu
* NOVO: diminuiu

$line$

$center$$underline$Observações

Para rodar o script shell, deve-se dar permissão ao mesmo com:

@   chmod +x getresults.sh

E deve-se ter Python3 instalado em máquina, sendo acessado pelo
comando python3, senão, alterar chamada ao interpretador Python
no código do script.





