
  Guilherme Dantas

  Análise do desempenho de cada algoritmo de substituição:

  == NRU (Not Recently Used)

  Para o arquivo compilador.log:

  $ ./sim-virtual NRU compilador.log 8 16
  [Simulator] Executing...
  [Simulator] Input file: compilador.log
  [Simulator] Physic Memory size: 16
  [Simulator] Page size: 8
  [Simulator] Page Replacement Algorithm: NRU
  [Simulator] Number of page faults: 2544
  [Simulator] Number of pages written: 496
  [Simulator] Done in 00m 05s.

  $ ./sim-virtual NRU compilador.log 8 8
  [Simulator] Executing...
  [Simulator] Input file: compilador.log
  [Simulator] Physic Memory size: 8
  [Simulator] Page size: 8
  [Simulator] Page Replacement Algorithm: NRU
  [Simulator] Number of page faults: 19597
  [Simulator] Number of pages written: 16572
  [Simulator] Done in 01m 16s.

  $ ./sim-virtual NRU compilador.log 8 1
  [Simulator] Executing...
  [Simulator] Input file: compilador.log
  [Simulator] Physic Memory size: 1
  [Simulator] Page size: 8
  [Simulator] Page Replacement Algorithm: NRU
  [Simulator] Number of page faults: 85980
  [Simulator] Number of pages written: 47693
  [Simulator] Done in 05m 42s.

  (Imagine com 1 MB de memória e páginas de 32 KB...)

  Percebe-se que com um número maior de páginas na memória principal,
  o algoritmo NRU é mais eficiente. Como o número de páginas em memória
  principal é calculado pela razão do tamanho da memória pelo tamanho de
  uma página, pode-se ver que a complexidade do algoritmo NRU para esta
  implementação é diretamente proporcional ao tamanho da página e inver-
  samente proporcional ao tamanho da memória.
