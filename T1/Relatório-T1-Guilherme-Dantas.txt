┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                              ┃
┃  INF1019 - 2019.1 - L. F. Seibel                                             ┃
┃                                                            Guilherme Dantas  ┃
┃  Trabalho 1 - 2a iteração                                                    ┃
┃                                                                     1713155  ┃
┃                                                                              ┃
┃                Escalonamento em Múltiplos Níveis com Feedback                ┃
┃                ⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺                ┃
┃                                                                              ┃
┃  Contém nesta pasta os seguintes arquivos:                                   ┃
┃                                                                              ┃
┃  algorithm.txt     Descrição do algoritmo (1a iteração)                      ┃
┃  algorithm2.txt    Descrição de modificações no algoritmo (2a iteração)      ┃
┃  main.c            Módulo interpretador e escalonador                        ┃
┃  Makefile          Arquivo make que gera os constructos                      ┃
┃  prog.c            Módulo para programa-usuário                              ┃
┃  queue.c           Módulo de implementação de fila                           ┃
┃  queue.h           Módulo de interface de fila                               ┃
┃  resultado.txt     Saída do programa para teste proposto                     ┃
┃  semlib.c          Módulo de implementação de semáforos                      ┃
┃  semlib.h          Módulo de interface de semáforos                          ┃
┃  test_queue.c      Módulo de testes do módulo fila                           ┃
┃                                                                              ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                                                                              ┃
┃  O teste do módulo main.c foi realizado com o programa prog (cujo            ┃
┃  código-fonte é prog.c) , passando como entrada ou um arquivo com um         ┃
┃  commando por linha ou manualmente digitando os comandos na shell e          ┃
┃  dando enter ao fim de cada comando. Os comandos, como constam no            ┃
┃  enunciado, são do tipo "exec prog \(%d(,%d)*\)" (em regexp).                ┃
┃                                                                              ┃
┃  Segue a análise do resultado obtido para o teste proposto em sala           ┃
┃  de aula na primeira iteração do trabalho.                                   ┃
┃  A saída completa emitida pelo programa em modo debug está no arquivo        ┃
┃  de nome "resultado.txt", para manter este documento enxuto.                 ┃
┃                                                                              ┃
┃  [1] exec A (1,1,1,1,1,1)                                                    ┃
┃                                                                              ┃
┃      Claramente, vê-se que o programa A deve permanscer na primeira          ┃
┃      fila pois todas as suas rajadas são iguais à 1, que é o quantum         ┃
┃      da primeira fila. Portanto, se ele começa na primeira fila, deve        ┃
┃      acabar nela. De fato, é o que acontece. Veja a linha 503.               ┃
┃                                                                              ┃
┃  [2] exec B (5,4,4,4)                                                        ┃
┃                                                                              ┃
┃      A primeira rajada é "divida" em três partes: 1 - 2 - 3.                 ┃
┃      A primeira é "consumida" pela fila 1, a segunda, pela fila 2, e         ┃
┃      a última pela fila 3. Só que a última rajada acaba antes do             ┃
┃      quantum (de 4). Então ele entra em I/O, vai para a segunda fila,        ┃
┃      e lá executa apenas 2, vai para a terceira fila, lá executa os          ┃
┃      dois restantes. Etc... Até acabarem todos os raios. Portanto,           ┃
┃      ele oscila entre a segunda e terceira fila, como pode-se ver            ┃
┃      pelos resultados.                                                       ┃
┃                                                                              ┃
┃  [3] exec C (14,8)                                                           ┃
┃                                                                              ┃
┃      A primeira rajada visivelmente é maior que a soma dos quantums          ┃
┃      das filas ( 14 > 1 + 2 + 4 ), portanto, ele vai até a última fila.      ┃
┃      E lá, permanece até entrar em I/O. Depois da primeira interrupção       ┃
┃      sobram 14 - 7 = 7. Mais uma interrupção na terceira fila.               ┃
┃      7 - 4 = 3. Ele entra em I/O antes de acabar o quantum, então, após      ┃
┃      o I/O, vai para a fila acima. Lá, executa 2. 8 - 2 = 6. Ao execeder     ┃
┃      o quantum de 2, desce à terceira fila, sobrando 6. Excede o quantum     ┃
┃      de 4, e, depois da interrupção, executa mais 2, terminando na           ┃
┃      terceira fila. O que acontece, na linha 534.                            ┃
┃                                                                              ┃
┃  [4] exec D (3,5,9,6)                                                        ┃
┃                                                                              ┃
┃      3 - 1 = 2. 2 - 2 = 0. Isto é, excede o quantum de 1 da primeira fila,   ┃
┃      sobram 2. Vai para a segunda fila por exceder o quantum, e permanece    ┃
┃      na segunda fila pelo quantum coincidir com o I/O. 5 - 2 = 3. 3 < 4.     ┃
┃      Ou seja, excede o quantum de 2, vai para a terceira fila, aonde acaba   ┃
┃      mais cedo que o quantum. Entrando em I/O, e sendo inserido na segunda   ┃
┃      fila norvamente. 9 - 2 = 7. 7 - 4 = 3. 3 < 4. Novamente, vai da fila    ┃
┃      2 para a fila 3. Excede o quantum de 4, mas permanesce na fila 3. E     ┃
┃      lá entra em I/O antes do quantum, retornando à fila 2. 6 - 2 = 4.       ┃
┃      4 = 4. Agora, na fila 2, excede o quantum, vai para a fila 3, e lá      ┃
┃      termina coincidindo com o quantum. Portanto, termina na fila 3, como    ┃
┃      pode-se ver nos resultados - mais especificamente na linha 548.         ┃
┃                                                                              ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                                                                              ┃
┃  Para reproduzir os testes na sua máquina, você pode optar por uma das       ┃
┃  duas distribuições do programa:                                             ┃
┃                                                                              ┃
┃  RELEASE:                                                                    ┃
┃  $ make -B                                                                   ┃
┃                                                                              ┃
┃  DEBUG:                                                                      ┃
┃  $ make debug -B                                                             ┃
┃                                                                              ┃
┃  E, após gerados gerados os arquivos binários, execute o programa            ┃
┃  principal normalmente. Você pode sempre optar por digitar os                ┃
┃  comandos manualmente:                                                       ┃
┃  $ ./main                                                                    ┃
┃                                                                              ┃
┃  ...ou vindo de um arquivo:                                                  ┃
┃  $ ./main < input.txt                                                        ┃
┃                                                                              ┃
┃  A distribuição debug, como é de se esperar, é muito mais verbosa que        ┃
┃  a release. Não é recomendado redefinir a saída para um arquivo pois         ┃
┃  percebi que a saída stdout de processos filhos não é redirecionada          ┃
┃  para o stdout do pai, estranhamente. Portanto, se não quiser perder         ┃
┃  trechos da saída do programa que são impressos pelos processos filhos,      ┃
┃  use a saída padrão da shell!                                                ┃
┃                                                                              ┃
┃  $ ./main < input.txt > output.txt                                           ┃
┃  (não faça isso)                                                             ┃
┃                                                                              ┃
┃  $ ./main > output.txt                                                       ┃
┃  (nem isso)                                                                  ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
