┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓
┃                                                                              ┃
┃  INF1019 - 2019.1 - L. F. Seibel                                             ┃
┃                                                            Guilherme Dantas  ┃
┃  Trabalho 1                                                                  ┃
┃                                                                     1713155  ┃
┃                                                                              ┃
┃                Escalonamento em Múltiplos Níveis com Feedback                ┃
┃                ⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺⎺                ┃
┃                                                                              ┃
┃  Contém nesta pasta os seguintes arquivos:                                   ┃
┃                                                                              ┃
┃  algorithm.txt     Estudo do algoritmo do escalonador (EN)                   ┃
┃  main.c            Módulo interpretador e escalonador                        ┃
┃  Makefile          Arquivo make que gera os constructos                      ┃
┃  prog.c            Módulo para programa-usuário                              ┃
┃  queue.c           Módulo de implementação de fila (EN)                      ┃
┃  queue.h           Módulo de interface de fila (EN)                          ┃
┃  resultados.txt    Saída do programa para cada caso de teste                 ┃
┃  Relatório...txt   Este documento                                            ┃
┃  semlib.c          Módulo de implementação de semáforos                      ┃
┃  semlib.h          Módulo de interface de semáforos                          ┃
┃  test_queue.c      Módulo de testes do módulo fila (EN)                      ┃
┃                                                                              ┃
┃  (EN) ... English                                                            ┃
┃                                                                              ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                                                                              ┃
┃  O teste do módulo main.c foi realizado com o programa prog (cujo            ┃
┃  código-fonte é prog.c , passando como entrada ou um arquivo com um          ┃
┃  commando por linha ou manualmente digitando os comandos na shell e          ┃
┃  dando enter ao fim de cada comando. Os comandos, como constam no            ┃
┃  enunciado, são do tipo "exec prog (%d(,%d)*)".                              ┃
┃                                                                              ┃
┃  Segue a análise dos resultados obtidos e esperados de cada teste.           ┃
┃  A saída completa emitida pelo programa em modo debug está no arquivo        ┃
┃  de nome "resultados.txt", para manter este documento enxuto.                ┃
┃                                                                              ┃
┃  [1] exec prog (1,2,3)                                                       ┃
┃                                                                              ┃
┃      Pode-se ver que ocorreram 6 rajadas, intercaladas de 2 interrup-        ┃
┃      ções de IO - que condiz com o comando. Além disso, o número de          ┃
┃      rajadas emitidas pelo programa usuário nunca ultrapassou o quantum      ┃
┃      da fila em que estava.                                                  ┃
┃                                                                              ┃
┃  [2] exec prog (12,1,1,1,1)                                                  ┃
┃                                                                              ┃
┃      Além de a quantidades de rajadas somarem 16, e a quantidade de in-      ┃
┃      terrupções somarem 4, como esperado, pôde-se ver que o escalonador      ┃
┃      desempenhou bem a tarefa de catalogar um comportamento mais CPU         ┃
┃      bound e pô-lo numa fila de menor prioridade. No caso, a rajada de       ┃
┃      12 u.t. levou o processo usuário a cair não só na última fila mas       ┃
┃      a ultrapassar o quantum desta - e permanecendo na útlima fila,          ┃
┃      obviamente. A partir desta rajada, o programa tem um comportamento      ┃
┃      exclusivamente IO bound, o que o leva à primeira fila novamente.        ┃
┃                                                                              ┃
┃  [3] exec prog (0,0,0,0)                                                     ┃
┃                                                                              ┃
┃      Aqui testa a flexibilidade do código do programa-usuário para lidar     ┃
┃      com rajadas nulas. Vê-se que o escalonador o pôe na primeira fila,      ┃
┃      e lá ele permanece até o fim, já que é um processo que nunca ultra-     ┃
┃      passa o quantum da primeira fila.                                       ┃
┃                                                                              ┃
┃  [4] exec prog (3,1,1)                                                       ┃
┃                                                                              ┃
┃      Aqui, foi alterado* o u.t de 1 segundo para 2 segundos, para testar     ┃
┃      o caso em que o processo que está rodando na primeira fila acaba        ┃
┃      antes do quantum ( 1 u.t. = 2s ). Vê-se que ele permanece na pri-       ┃
┃      meira fila.                                                             ┃
┃                                                                              ┃
┃      * relatório.txt explica como reproduzir na sua máquina esta alteração   ┃
┃                                                                              ┃
┃  [5] exec prog (1,1,1)                                                       ┃
┃      exec prog (2,2,2)                                                       ┃
┃      exec prog (3,3,3)                                                       ┃
┃                                                                              ┃
┃      Finalmente, chegamos aos casos multiprocessados. Por isso tratarei      ┃
┃      estes como processos e não mais como "programas" (pois são, no final    ┃
┃      das contas, instâncias do mesmo executável). Bom... pode-se ver que     ┃
┃      há processos mais IO-bound que outros, mais CPU-bound. É esperado       ┃
┃      que o primeiro processo listado seja terminado primeiro que o se-       ┃
┃      gundo, e este, terminado primeiro que o terceiro. E é o que real-       ┃
┃      mente acontece. Verá também que o programa em distribuição debug        ┃
┃      também exibe na saída os processos que ainda estão na fila, e os        ┃
┃      que estão bloqueados por IO, toda vez que um processo é terminado.      ┃
┃                                                                              ┃
┃  [6] exec prog (1,1,1)                                                       ┃
┃      exec prog (1,1,1)                                                       ┃
┃      exec prog (1,1,1)                                                       ┃
┃                                                                              ┃
┃      Com processos idênticos, é esperado que tenham exatamente o mesmo       ┃
┃      comportamento, certo? Bom, não exatamente. Pode-se ver na saída         ┃
┃      que o primeiro processo entrou em IO na primeira vez que foi            ┃
┃      escalonado, enquanto os outros dois ultrapassaram o quantum de          ┃
┃      1 u.t. - ou seja, não chegaram a mandar o sinal para o pai. Isto        ┃
┃      pode estar atrelado ao fato de não se saber quando que um proce-        ┃
┃      sso irá receber um sinal. Esta assincronia faz com que processos        ┃
┃      criados com os mesmos parâmetros e condições de ambiente possam         ┃
┃      ter comportamentos distintos.                                           ┃
┃                                                                              ┃
┃      Mais detalhadamente, o que ocorre é que o processo filho ao             ┃
┃      executar "prog", manda um sinal SIGUSR1 ao pai sinalizando que          ┃
┃      entrou no bloco de código esperado. Este recebe o sinal e inter-        ┃
┃      rompe o filho, isto é, manda um sinal SIGSTOP a ele. Pela natureza      ┃
┃      assíncrona e incerta dos sinais, não se sabe em que parte do código     ┃
┃      o filho foi parado. E consequentemente, seu comportamento é incerto.    ┃
┃                                                                              ┃
┣━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┫
┃                                                                              ┃
┃  Para reproduzir os testes na sua máquina, você pode optar por uma das       ┃
┃  duas distribuições do programa:                                             ┃
┃                                                                              ┃
┃  RELEASE:                                                                    ┃
┃  $ make -B                                                                   ┃
┃                                                                              ┃
┃  DEBUG:                                                                      ┃
┃  $ make debug -B                                                             ┃
┃                                                                              ┃
┃  E, após gerados gerados os arquivos binários, execute o programa            ┃
┃  principal normalmente. Você pode sempre optar por digitar os                ┃
┃  comandos manualmente:                                                       ┃
┃  $ ./main                                                                    ┃
┃                                                                              ┃
┃  ...ou vindo de um arquivo:                                                  ┃
┃  $ ./main < input.txt                                                        ┃
┃                                                                              ┃
┃  A distribuição debug, como é de se esperar, é muito mais verbosa que        ┃
┃  a release. Não é recomendado redefinir a saída para um arquivo pois         ┃
┃  percebi que a saída stdout de processos filhos não é redirecionada          ┃
┃  para o stdout do pai, estranhamente. Na verdade, nem sequer são impre-      ┃
┃  ssos na saída padrão da shell. Portanto, se não quiser perder trechos       ┃
┃  da saída do programa que são impressos pelos processos filhos, use a        ┃
┃  saída padrão da shell!                                                      ┃
┃                                                                              ┃
┃  $ ./main < input.txt > output.txt                                           ┃
┃  (não faça isso)                                                             ┃
┃                                                                              ┃
┃  $ ./main > output.txt                                                       ┃
┃  (nem isso)                                                                  ┃
┃                                                                              ┃
┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛
